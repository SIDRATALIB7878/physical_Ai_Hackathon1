import os
import sys
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from fastapi.middleware.cors import CORSMiddleware
from dotenv import load_dotenv

# Add the project root to the path so we can import modules
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.insert(0, project_root)

# Load environment variables
load_dotenv()

app = FastAPI()

# Configure CORS
origins = ["http://localhost:3000", "http://localhost:3001", "http://127.0.0.1:3000", "http://127.0.0.1:3001"]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class Query(BaseModel):
    question: str

# Initialize the RAG Agent
try:
    from backend.rag_agent.rag_agent import RAGAgent
    rag_agent = RAGAgent()
    print("RAG Agent initialized successfully")
except Exception as e:
    print(f"Error initializing RAG Agent: {e}")
    rag_agent = None

# Initialize mock retrieval tool as fallback
try:
    from backend.rag_agent.mock_retrieval_tool import retrieve_book_content as mock_retrieve
    print("Mock retrieval tool loaded successfully")
except Exception as e:
    print(f"Error loading mock retrieval tool: {e}")
    mock_retrieve = None

@app.post("/ask")
async def ask(q: Query):
    if rag_agent:
        try:
            # Use the RAG agent to answer the question
            response = rag_agent.ask(q.question)
            return {
                "answer": response
            }
        except Exception as e:
            print(f"Error with RAG Agent: {e}")
            # Fall back to mock implementation if real agent fails
            if mock_retrieve:
                try:
                    # Get mock results
                    mock_results = mock_retrieve(q.question, "default_book", 3)
                    # Generate a response based on mock results
                    response = f"Based on the book content: {mock_results}\n\nThis is a simulated response. In a real implementation, this would be generated by an AI model based on the retrieved content."
                    return {
                        "answer": response
                    }
                except Exception as mock_error:
                    print(f"Error with mock retrieval: {mock_error}")
                    raise HTTPException(status_code=500, detail=f"Sorry, I encountered an error. Please try again. Error: {str(mock_error)}")
            else:
                raise HTTPException(status_code=500, detail=f"Sorry, I encountered an error. Please try again. Error: {str(e)}")
    elif mock_retrieve:
        # Use mock retrieval as fallback
        try:
            # Get mock results
            mock_results = mock_retrieve(q.question, "default_book", 3)
            # Generate a response based on mock results
            response = f"Based on the book content: {mock_results}\n\nThis is a simulated response. In a real implementation, this would be generated by an AI model based on the retrieved content."
            return {
                "answer": response
            }
        except Exception as mock_error:
            print(f"Error with mock retrieval: {mock_error}")
            raise HTTPException(status_code=500, detail=f"Sorry, I encountered an error. Please try again. Error: {str(mock_error)}")
    else:
        raise HTTPException(status_code=500, detail="RAG Agent and mock retrieval not properly configured")
